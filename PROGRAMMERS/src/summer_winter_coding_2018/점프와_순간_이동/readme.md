## Programmers - 점프와 순간 이동 
- Level 2 
- Implement
- Summer/Winter Coding(~2018)
🔗[점프와 순간 이동 문제 바로가기](https://programmers.co.kr/learn/courses/30/lessons/12980)



## 풀이

처음에는 이 문제를 dfs나 down-top 방식으로 풀어야 하나 고민했다.
그러나 최악의 경우가 10억이고, 최소한의 배터리를 사용해야 하므로 down-top 방식을 사용하여 문제를 풀었다.

만약 N이 짝수라면, N/2인 곳에서 x2만큼 이동하는 순간이동을 통해 도착할 수 있고, 홀수라면 무조건 점프를 최소 한번 이상 해주어야한다.
따라서 N이 0이 될때까지 N이 짝수라면 /2를, 홀수라면 -1을 해주어 N이 0이 되는 순간 답을 구해주었다.
물론 점프를 하는 경우에만 배터리가 소모되므로 홀수인 경우에만 ans+1을 해주어야 한다.


## 소스코드
~~~java
import java.util.*;

public class Solution {
    public int solution(int n) {
        int ans = 0;

        while(n!=0){
            // 짝수일 경우 
            if(n%2==0){
                n /= 2;
            }
            // 홀수일 경우 
            else if(n%2==1){
                n -= 1;
                ans += 1;
            }
        }
        return ans;
    }
}
~~~

## 결과 

| 정확성  | 테스트 |
|----|----|
|테스트 1 |	통과 (0.02ms, 72.2MB)|
|테스트 2 |	통과 (0.02ms, 74.8MB)|
|테스트 3 |	통과 (0.02ms, 84.6MB)|
|테스트 4 |	통과 (0.02ms, 74.4MB)|
|테스트 5 |	통과 (0.03ms, 77.6MB)|
|테스트 6 |	통과 (0.03ms, 79MB)|
|테스트 7 |	통과 (0.03ms, 78.3MB)|
|테스트 8 |	통과 (0.02ms, 73.8MB)|
|테스트 9 |	통과 (0.02ms, 66MB)|
|테스트 10 |	통과 (0.03ms, 78.7MB)|
|테스트 11 |	통과 (0.02ms, 70.7MB)|
|테스트 12 |	통과 (0.03ms, 74MB)|
|테스트 13 |	통과 (0.02ms, 77.2MB)|
|테스트 14 |	통과 (0.02ms, 71.1MB)|
|테스트 15 |	통과 (0.03ms, 66.1MB)|
|테스트 16 |	통과 (0.02ms, 66.4MB)|
|테스트 17 |	통과 (0.02ms, 78.3MB)|
|테스트 18 |	통과 (0.02ms, 76.1MB)|
---
|효율성 | 테스트|
|----|----|
|테스트 1 |	통과 (0.03ms, 53.1MB)|
|테스트 2 |	통과 (0.02ms, 52.1MB)|
|테스트 3 |	통과 (0.02ms, 52.3MB)|
|테스트 4 |	통과 (0.02ms, 51.8MB)|
|테스트 5 |	통과 (0.02ms, 52.1MB)|
|테스트 6 |	통과 (0.02ms, 52.2MB)|
|테스트 7 |	통과 (0.02ms, 51.6MB)|
|테스트 8 |	통과 (0.02ms, 52.4MB)|
|테스트 9 |	통과 (0.02ms, 52MB)|
|테스트 10|	통과 (0.07ms, 52.1MB)|
